import numpy as np
import pandas as pd
#pip install giotto-tda
from gtda.homology import VietorisRipsPersistence
import csv

#This function generates a distance_matrix that represents the Euclidean distance between the points based on postion
#The input of function calculate_distance_matrix should be a list in form of:
#[(x_1,y_1,m_11,m_21,...,m_n1),(x_2,y_2,m12,m22,...,m_n1),...,(x_k,y_k,m_1k,m_2k,...,m_nk)]
#in which x_i,y_i are the x and y coordinate for the certain cell and mi_i to m_ni are the values of markers/features for each cell
class Real_Distance:
  def real_euclidean_distance(point1, point2):
      return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)
  def calculate_distance_matrix(point_cloud):
      num_points = len(point_cloud)
      distance_matrix = np.zeros((num_points, num_points))

      for i in range(num_points):
          for j in range(i + 1, num_points):
              # the input should have x-axis and y-axis in the first 2 entires
              distance = Real_Distance.real_euclidean_distance(point_cloud[i][:2], point_cloud[j][:2])
              distance_matrix[i, j] = distance
              distance_matrix[j, i] = distance

      return distance_matrix

#This function returns a dictionary that consists the paired cells that Euclidean distance between them no more than epsilon
#The input should be the distance matrix generated by function calculate_distance_matrix and a given distance threshold value epsilon
#The output has form like this:
#{p_1: [p_2], p_3: [p_4, p_5], ...}
#in which p_1,p_3,... are unqiue key values representing the points' label (from 1 to n by sequence)
#the value [p_2,...] for each key are the points that within the certain distance to the key points
class Find_Pairs:
    def find_pairs_within_epsilon(distance_matrix, epsilon):
        num_points = distance_matrix.shape[0]
        indices = np.arange(num_points)
        labels_dict = {}

        for i in range(num_points):
            mask = distance_matrix[i, i+1:] <= epsilon
            labels = indices[i+1:][mask].tolist()
            if labels:
                labels_dict[i] = labels

        return labels_dict

#This function returns a dissimilarity matrix between cells by comparing the marker values
#The input will be the point_cloud, a list in form of:
#[(x_1,y_1,m_11,m_21,...,m_n1),(x_2,y_2,m12,m22,...,m_n1),...,(x_k,y_k,m_1k,m_2k,...,m_nk)]
#in which x_i,y_i are the x and y coordinate for the certain cell and mi_i to m_ni are the values of markers/features for each cell
#Choose the distance matrix function that is needed, can add functions for other dissimilarity matrix
class Get_Weight:
    #Original Euclidean Dissimilarity Matrix
    def calculate_distances(point_cloud):
        num_points = len(point_cloud)
        distances = np.zeros((num_points, num_points))

        for i in range(num_points):
            for j in range(i + 1, num_points):
                distance = np.linalg.norm(np.array(point_cloud[i][2:-1]) - np.array(point_cloud[j][2:-1]))
                distances[i, j] = distance
                distances[j, i] = distance
        return distances
    #Rescaled Euclidean Dissimilarity Matrix
    def rescale_distance(point_cloud):
        distance_matrix = Get_Weight.calculate_distances(point_cloud)
        max_distance = np.max(distance_matrix)
        rescaled_matrix = distance_matrix - max_distance
        rescaled_matrix /= -max_distance
        rescaled_matrix = 2 * rescaled_matrix - 1
        return rescaled_matrix

#This function returns the adjacency matrix representing the graph input for persistent homology
#The inputs are:
#connected_nodes = labels_within_epsilon
#distance_matrix = np.array(dissimilarity_matrix)
#Note that Giotto-tda requires the adjacency matrix use np.inf to represent the unconnected edge
class Graph:
    def generate_adjacency_matrix(connected_nodes, distance_matrix):
        num_nodes = len(distance_matrix)
        adjacency_matrix = np.full((num_nodes, num_nodes), np.inf)

        for node, connected in connected_nodes.items():
            adjacency_matrix[node, connected] = distance_matrix[node, connected]
            adjacency_matrix[connected, node] = distance_matrix[node, connected]

        np.fill_diagonal(adjacency_matrix, 0)
        return adjacency_matrix

#This function returns the list of persistent homology results
#imput should be [np.array(adjacency_matrix)] according to giotto-tda's requirements
class TDA:
    def PH(data):
        VR = VietorisRipsPersistence(metric="precomputed",)
        diagrams = VR.fit_transform(data)
        return diagrams

#Given a certain matrix, filter the neg and pos part of it.
class Pos_Neg:
    def filter_positive_entries(matrix):
        return np.where(matrix >= 0, matrix, np.inf)

    def filter_negative_entries(matrix):
        return np.where(matrix <= 0, matrix, np.inf)

#run to get the PH list and store it in a csv file
#we try one FOV first
if __name__ == '__main__':
    # change the address accordingly
    data_1 = pd.read_csv("/content/drive/MyDrive/GIS/A_cell_table_size_normalized.csv")
    # change the fov name accordingly
    data1 = data_1[data_1['fov'] == '2022-12-03T15-18-19_BIGFISH1_pA_s1_R10C5']
    X1_coor = data1[["centroid-0", "centroid-1"]].values
    # change the marker range accordingly
    overlapping_markers = data1.columns[2:48]
    Y1 = data1[overlapping_markers].values
    point_cloud_ini = np.concatenate((X1_coor, Y1), axis=1)
    # add a label for reference
    point_cloud = [(*row, i) for i, row in enumerate(point_cloud_ini)]

    #create a csv file, change the address accordingly
    csv_file = 'test.csv'
    #label for reference (tracking value of the epsilon/distance between 2 cells)
    columns = ['birth', 'death', 'dimension', 'label']
    # generate the distance matrix first
    distance_matrix = Real_Distance.calculate_distance_matrix(point_cloud)
    #dissimilarity_matrix = Get_Weight.rescale_distance(point_cloud) #if want to run the rescaled Euclidean matrix, rmb to command next line
    dissimilarity_matrix = Get_Weight.calculate_distances(point_cloud)

    # Open the CSV file in write mode
    with open(csv_file, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(columns)
        #change the n range accordingly
        for n in range(1, 15):
            #change the epsilon value 20 * n accordingly
            labels_within_epsilon = Find_Pairs.find_pairs_within_epsilon(distance_matrix, 20 * n)
            X = []
            connected_nodes = labels_within_epsilon
            dissimilarity_matrix = np.array(dissimilarity_matrix)
            adjacency_matrix = Graph.generate_adjacency_matrix(connected_nodes, dissimilarity_matrix)

            #if a dissimilarity matrix with neg and pos parts is used and want to consider neg and pos seperately, please use the following command parts
            #pos_matrix = Pos_Neg.filter_positive_entries(adjacency_matrix)
            #neg_matrix = Pos_Neg.filter_negative_entries(adjacency_matrix)
            #pos_diagram = TDA.PH([np.array(pos_matrix)])
            #neg_diagram = TDA.PH([np.array(neg_matrix)])
            #for j in pos_diagram[0].tolist():
            #    X.append(j)
            #for i in neg_diagram[0].tolist():
            #    X.append(i)

            #if the above part is used, please command this part
            result = TDA.PH([np.array(adjacency_matrix)])
            for i in result[0].tolist():
                X.append(i)
            #until here

            for row in X:
                writer.writerow(row + [n])

